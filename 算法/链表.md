# 链表

## 1.链表理论基础

单链表

双链表

循环链表

## 2.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

```java
//虚拟头结点
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //如果头结点为空，则返回头结点
        if(head == null){
            return head;
        }
        //设置虚拟头结点，值为-1，指向头结点
        ListNode dummy = new ListNode(-1,head);
        //设置前置结点为虚拟头结点
        ListNode previous = dummy;
        //设置当前结点为头结点
        ListNode current = head;
        /*当当前结点不为空时，令当前结点存储的数据与给定的数据比对，
        若相同，则将当前结点指向的下一结点赋值给前置结点的指向，
        若不同，则将当前结点赋设为前置结点，
        最后，将当前结点指向的下一结点设为当前结点，
        返回虚拟头结点。
        */
        while(current != null){
            if(current.val == val){
                previous.next = current.next;
            }else{
                previous = current;
            }
            current = current.next;
        }
        return dummy.next;
    }
}

//递归
class Solution{
	public ListNode removeElements(ListNode head,int val){
        if(head == null){
            return head;
        }
        head.next = removeElements(head.next,val);
        return head.val==val?head.next:head;
    }
}
```



## 3.设计链表

[707.设计链表](https://leetcode.cn/problems/design-linked-list/description/)

```java
class MyLinkedList {
    int size;
    ListNode head;

    //初始化MyLinkedList对象
    public MyLinkedList() {
        //设置初始大小为0
        size = 0;
        //为虚拟头结点赋值为0
        head = new ListNode(0);
    }

    //获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1
    public int get(int index) {
        //链表的下标从零开始
        if(index < 0 || index >= size){
            return -1;
        } 
        //设置当前结点为虚拟头结点
        ListNode cur = head;
        //从虚拟头结点开始查找
        for(int i =0;i<=index;i++){
            cur = cur.next;
        }
        return cur.val;
    }
    
    //将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    //将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    //将一个值为 val 的节点插入到链表中下标为 index 的节点之前。
    //如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。
    //如果 index 比链表长度更大，该节点将不会插入 到链表中。
    public void addAtIndex(int index, int val) {
        //当index比链表长度更大时，将不会插入
        if(index>size){
            return;
        }
        //当index小于0时，将其置为0，使其在头结点之前插入
        index = Math.max(0,index);
        size++;
        //设置前置结点为虚拟头结点
        ListNode pre = head;
        //查找插入位置的前置结点
        for(int i=0;i<index;i++){
            pre = pre.next;
        }
        //新建插入结点
        ListNode toAdd = new ListNode(val);
        //令插入结点指向前置结点所指向的结点
        toAdd.next= pre.next;
        //令前置结点指向插入结点
        pre.next = toAdd;
    }
    
    // 如果下标有效，则删除链表中下标为 index 的节点。
    public void deleteAtIndex(int index) {
        //判断下标是否有效
        if(index >= size || index <0){
            return;
        }
        size--;
        //查找插入下标的前置结点
        ListNode pre = head;
        for(int i = 0;i<index;i++){
            pre = pre.next;
        }
        //令前置结点指向原先指向的结点所指向的结点
        pre.next = pre.next.next;
    }
}

class ListNode{
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val){this.val = val;}
}
```



## 4.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

```java
//双指针
class Solution {
    public ListNode reverseList(ListNode head) {
        //设置前置结点为空
        ListNode pre = null;
        //设置当前结点为头结点
        ListNode cur = head;
        //设置临时结点用于存储
        ListNode temp = null;
        //当当前结点不为空时，执行循环
        while(cur!=null){
            //临时结点存储当前结点指向的下一结点
            temp = cur.next;
            //令当前结点指向前置结点
            cur.next = pre;
            //令前置结点等于当前结点
            pre = cur;
            //令当前结点等于临时结点
            cur=temp;
        }
        return pre;
    }
}
//递归
class Solution {
    //原始方法，初始化
    public ListNode reverseList(ListNode head) {
        return reverse(null,head);
    }
    public ListNode reverse(ListNode pre,ListNode cur){
        if(cur == null){
            return pre;
        }
        ListNode temp = null;
        temp = cur.next;
        cur.next = pre;
        //最后一步返回代替了pre = cur;和cur = temp;，直接将cur作为参数pre，temp作为参数cur
        return reverse(cur,temp);
    }
}
```



## 5.两两交换链表中的节点

[24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

```java
//第一种解法
class Solution {
    public ListNode swapPairs(ListNode head) {
        //设置虚拟头结点
        ListNode dummy = new ListNode(-1,head);
        //设置当前结点，并将其指向虚拟头结点
        ListNode cur = dummy;
        //设置临时结点，存储两两交换的结点中的第一个结点
        ListNode first;
        //设置临时结点，存储两两交换的结点中的第二个结点
        ListNode second;
        //设置临时结点，存储第二个结点指向的结点
        ListNode temp;
        //确保两个交换的结点都存在,先判断第一个结点是否存在可以避免报错
        while(cur.next != null && cur.next.next !=null ){
            first = cur.next;
            second = cur.next.next;
            temp = cur.next.next.next;
            //当前结点指向第二个结点
            cur.next = second;
            //第二个结点指向第一个结点
            second.next = first;
            //第一个结点指向临时结点
            first.next = temp;
            //设置当前结点为第一个结点
            cur = first;
        }
        return dummy.next;
    }
}

//递归
class Solution {
    public ListNode swapPairs(ListNode head) {
        //检测链表结点数目是否符合交换条件
        if(head == null || head.next == null){
            return head;
        }
        //新建结点newHead，将head结点指向的下一结点赋值给它
        ListNode newHead = head.next;
        //令head结点指向后两个结点交换后的第一个结点
        head.next = swapPairs(newHead.next);
        //令newHead指向head
        newHead.next = head;
        return newHead;
    }
}
```



## 6.删除链表的倒数第N个节点

[19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        //慢指针
        ListNode fast = dummy;
        //快指针
        ListNode slow = dummy;
        //令快慢指针相差n+1
        for(int i= 0;i<=n;i++){
            fast = fast.next;
        }
        //快慢指针同时后移
        while(fast!=null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



## 7.链表相交

[链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

```java
//双指针法
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA=0;
        int lenB=0;
        int i = 0;
        //求headA的长度
        while(curA!=null){
            lenA++;
            curA = curA.next;
        }
        //求headB的长度
        while(curB!=null){
            lenB++;
            curB = curB.next;
        }
        //重置curA和curB
        curA = headA;
        curB = headB;

        int len=0;

        //根据lenA和lenB的大小分情况使得headA和headB的末尾对其
        if(lenA>lenB){
            len = lenA-lenB;
            for(i=0;i<len;i++){
                curA = curA.next;
            }
        }else{
            len = lenB-lenA;
            for(i=0;i<len;i++){
                curB = curB.next;
            }
        }

        while(curA!=null){
            if(curA == curB){
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}

//双指针+三目运算符
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null){
            return null;
        }
        ListNode curA = headA;
        ListNode curB = headB;
        //curA和curB都会遍历headA+headB，当存在相交点时会退出循环，返回相交点
        //不存在时，两者会同时进入null状态，并在此刻退出
        while(curA!=curB){
            //遍历完headA会进入headB继续遍历
            curA = curA == null ?headB:curA.next;
            //遍历完headB会进入headA继续遍历
            curB = curB == null ?headA:curB.next;
        }
        return curA;
    }
}
```



## 8.环形链表Ⅱ

[142.环形链表Ⅱ](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        //若成环则进入循环
        while(fast!=null&&fast.next!=null){
            //慢指针一次移动一个结点，快指针一次移动俩
            slow = slow.next;
            fast = fast.next.next;
            //快慢指针相遇，确定有环
            if(fast == slow){
                //分别在头结点和相遇结点设置index1和index2
                ListNode index1 = head;
                ListNode index2 = fast;
                //index1和index2相遇时就是环的入口结点
                while(index1!=index2){
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```
