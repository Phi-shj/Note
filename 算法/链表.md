# 链表

## 1.链表理论基础

单链表

双链表

循环链表

## 2.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

```java
//虚拟头结点
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //如果头结点为空，则返回头结点
        if(head == null){
            return head;
        }
        //设置虚拟头结点，值为-1，指向头结点
        ListNode dummy = new ListNode(-1,head);
        //设置前置结点为虚拟头结点
        ListNode previous = dummy;
        //设置当前结点为头结点
        ListNode current = head;
        /*当当前结点不为空时，令当前结点存储的数据与给定的数据比对，
        若相同，则将当前结点指向的下一结点赋值给前置结点的指向，
        若不同，则将当前结点赋设为前置结点，
        最后，将当前结点指向的下一结点设为当前结点，
        返回虚拟头结点。
        */
        while(current != null){
            if(current.val == val){
                previous.next = current.next;
            }else{
                previous = current;
            }
            current = current.next;
        }
        return dummy.next;
    }
}

//递归
class Solution{
	public ListNode removeElements(ListNode head,int val){
        if(head == null){
            return head;
        }
        head.next = removeElements(head.next,val);
        return head.val==val?head.next:head;
    }
}
```



## 3.设计链表

[707.设计链表](https://leetcode.cn/problems/design-linked-list/description/)

```java
class MyLinkedList {
    int size;
    ListNode head;

    //初始化MyLinkedList对象
    public MyLinkedList() {
        //设置初始大小为0
        size = 0;
        //为虚拟头结点赋值为0
        head = new ListNode(0);
    }

    //获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1
    public int get(int index) {
        //链表的下标从零开始
        if(index < 0 || index >= size){
            return -1;
        } 
        //设置当前结点为虚拟头结点
        ListNode cur = head;
        //从虚拟头结点开始查找
        for(int i =0;i<=index;i++){
            cur = cur.next;
        }
        return cur.val;
    }
    
    //将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    //将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    //将一个值为 val 的节点插入到链表中下标为 index 的节点之前。
    //如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。
    //如果 index 比链表长度更大，该节点将不会插入 到链表中。
    public void addAtIndex(int index, int val) {
        //当index比链表长度更大时，将不会插入
        if(index>size){
            return;
        }
        //当index小于0时，将其置为0，使其在头结点之前插入
        index = Math.max(0,index);
        size++;
        //设置前置结点为虚拟头结点
        ListNode pre = head;
        //查找插入位置的前置结点
        for(int i=0;i<index;i++){
            pre = pre.next;
        }
        //新建插入结点
        ListNode toAdd = new ListNode(val);
        //令插入结点指向前置结点所指向的结点
        toAdd.next= pre.next;
        //令前置结点指向插入结点
        pre.next = toAdd;
    }
    
    // 如果下标有效，则删除链表中下标为 index 的节点。
    public void deleteAtIndex(int index) {
        //判断下标是否有效
        if(index >= size || index <0){
            return;
        }
        size--;
        //查找插入下标的前置结点
        ListNode pre = head;
        for(int i = 0;i<index;i++){
            pre = pre.next;
        }
        //令前置结点指向原先指向的结点所指向的结点
        pre.next = pre.next.next;
    }
}

class ListNode{
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val){this.val = val;}
}
```



## 4.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

```java
//双指针
class Solution {
    public ListNode reverseList(ListNode head) {
        //设置前置结点为空
        ListNode pre = null;
        //设置当前结点为头结点
        ListNode cur = head;
        //设置临时结点用于存储
        ListNode temp = null;
        //当当前结点不为空时，执行循环
        while(cur!=null){
            //临时结点存储当前结点指向的下一结点
            temp = cur.next;
            //令当前结点指向前置结点
            cur.next = pre;
            //令前置结点等于当前结点
            pre = cur;
            //令当前结点等于临时结点
            cur=temp;
        }
        return pre;
    }
}
//递归
class Solution {
    //原始方法，初始化
    public ListNode reverseList(ListNode head) {
        return reverse(null,head);
    }
    public ListNode reverse(ListNode pre,ListNode cur){
        if(cur == null){
            return pre;
        }
        ListNode temp = null;
        temp = cur.next;
        cur.next = pre;
        //最后一步返回代替了pre = cur;和cur = temp;，直接将cur作为参数pre，temp作为参数cur
        return reverse(cur,temp);
    }
}
```



## 5.两两交换链表中的节点

## 6.删除链表的倒数第N个节点

## 7.链表相交

## 8.环形链表Ⅱ

## 9.总结篇



